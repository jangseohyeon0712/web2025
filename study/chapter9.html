<h1>Chapter 9</h1>
Chapter 9 summary
자바스크립트 객체 만들기
 <h2>객체란 Object</h2>

<li>프로그래밍에서 ‘객체’는 데이터를 저장하고 처리하는 기본 단위</li>
<li>자바스크립트에서 객체는 관련된 정보와 동작을 함께 모아 놓은 것</li>

<li>내장 객체 : 프로그래밍을 할 때 자주 사용하는 요소들을 자바스크립트에서 미리 정의해 놓은 객체</li>
<ul>
  <li>문서 객체 모델(DOM) : 웹 문서 자체도 객체이고 웹 문서에 포함된 이미지와 링크, 텍스트 필드 등은 모두 이미지 객체, 링크 객체, 폼 객체처럼 각각 별도의 객체.</li>
  <li>브라우저 객체 모델(B0M) : 웹 브라우저에서 사용하는 정보도 객체로 지정되어 있다.</li>
</ul>

<li>사용자 정의 객체 : 필요할 때마다 사용자가 만들어 사용하는 객체</li>
<h3>사용자 정의 객체 만들기</h3>

객체는 여러 개의 프로퍼티로 구성되어 있는데, 프로퍼티는 ‘키 : 값’ 형태를 가지고 있다.<br><br>

<b>키와 값</b><br>
객체를 만들 때는 객체 이름 다음에 중괄호({})를 사용하고,<br>
중괄호 사이에 ‘키 : 값’ 형식으로 필요한 프로퍼티를 나열한다.<br>
객체의 키는 문자열이나 숫자, 심벌만 사용할 수 있고,<br>
각 프로퍼티는 쉼표(,)를 넣어 구분한다.<br><br>

<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
객체명 {<br>
&nbsp;&nbsp;키1 : 값1,<br>
&nbsp;&nbsp;키2 : 값2,<br>
&nbsp;&nbsp;......<br>
}
</div>
<p>객체 선언하기</p>

(예) 책 정보를 담고 있는 book1<br><br>

<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
let book1 = {<br>
&nbsp;&nbsp;title : "웹 표준의 정석",<br>
&nbsp;&nbsp;pages : 648<br>
}<br>
book1&nbsp;&nbsp;// { title : "웹 표준의 정석", pages : 648 }
</div><br><br>

<ul>
  <li><b>프로퍼티</b>: 객체의 속성을 나타내는 항목</li>
  <li><b>key (키)</b>: title, pages와 같은 이름</li>
  <li><b>value (값)</b>: "웹 표준의 정석", 648과 같은 데이터</li>
</ul>
<p>객체 프로퍼티에 접근하기</p>

점 표기법이나 괄호 표기법 사용<br>
괄호 표기법을 사용할 경우 프로퍼티 키의 문자열에는 큰따옴표를 붙여야 한다<br><br>

<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
book1.title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 점 표기법. 프로퍼티키에 큰따옴표 없음<br>
book1["title"]&nbsp;&nbsp;&nbsp;&nbsp;// 괄호 표기법. 프로퍼티키에 큰따옴표 있음
</div><br><br>

<p>객체 프로퍼티 수정하기 및 추가하기</p>

<div style="background-color: #e0e0e0; padding: 6px; display: inline-block; font-family: monospace;">
객체명.키 = 값
</div><br><br>

<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
book1.pages = 50<br>
book1&nbsp;&nbsp;// { title: "웹 표준의 정석", pages: 50 }
</div><br><br>

<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
book1.author = "고경희"<br>
book1&nbsp;&nbsp;// { title: "웹 표준의 정석", pages: 50, author: "고경희" }
</div>
<p>빈 객체를 만든 후 프로퍼티를 추가하면서 객체를 만들 수 있음</p>

<p><b>빈 객체 만들기</b></p>
<div style="background-color: #f0f0f0; padding: 8px; display: inline-block;">
let book2 = {}&nbsp;&nbsp;&nbsp;&nbsp;또는&nbsp;&nbsp;&nbsp;&nbsp;let book2 = new Object()
</div><br><br>

<p><b>프로퍼티 추가하기</b></p>
<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
book2.title = "Javascript"<br>
book2.pages = 500<br>
book2.author = "고경희"<br>
book2<br>
// { title: "Javascript", pages: 500, author: "고경희" }
</div><br><br>

<p><b>프로퍼티 삭제하기</b></p>
<div style="background-color: #f0f0f0; padding: 10px; display: inline-block;">
delete book2.pages<br>
book2<br>
// { title: "Javascript", author: "고경희" }
</div>
<p>객체 중첩하기</p>

객체 안에 또다른 객체를 넣을 수 있다. – 둘 이상의 객체 중첩<br><br>

<div style="background-color: #f0f0f0; padding: 12px; width: fit-content; font-family: monospace;">
let student = {<br>
&nbsp;&nbsp;name : "Doremi",<br>
&nbsp;&nbsp;score : {<br>
&nbsp;&nbsp;&nbsp;&nbsp;history : 85,<br>
&nbsp;&nbsp;&nbsp;&nbsp;science : 94,<br>
&nbsp;&nbsp;&nbsp;&nbsp;average : function () {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (this.history + this.science) / 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br><br>

student.score.history&nbsp;&nbsp;// 85<br>
student.score.average()&nbsp;&nbsp;// 89.5
</div>
<p>객체 메서드 정의하기</p>

<li>메서드(method) : 객체의 프로퍼티 중 객체의 동작을 지정하는 함수</li>
<li>메서드를 선언하는 방법은 일반적인 함수를 선언하는 것과 비슷하다.</li><br>

<div style="background-color: #f0f0f0; padding: 10px; width: fit-content; font-family: monospace;">
메서드명 : function() {<br>
&nbsp;&nbsp;......<br>
}
</div><br>

<div style="display: flex; gap: 20px; font-family: monospace;">
  <div style="background-color: #f0f0f0; padding: 12px;">
    let book3 = {<br>
    &nbsp;&nbsp;title : "점프 투 파이썬",<br>
    &nbsp;&nbsp;pages : 360,<br>
    &nbsp;&nbsp;<span style="color: red;">buy : function () {</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;console.log("이 책을 구입했습니다.");<br>
    &nbsp;&nbsp;}<br>
    }
  </div>

  <div style="background-color: #f0f0f0; padding: 12px;">
    <b>ES6</b><br><br>
    let book3 = {<br>
    &nbsp;&nbsp;title : "점프 투 파이썬",<br>
    &nbsp;&nbsp;pages : 360,<br>
    &nbsp;&nbsp;<span style="color: red;">buy () {</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;console.log("이 책을 구입했습니다.");<br>
    &nbsp;&nbsp;}<br>
    }
  </div>
</div>
<p>메서드와 this</p>

this: 메서드에서 객체 안에 있는 프로퍼티값을 사용할 때, 현재 객체를 가리키는 예약어<br><br>

<div style="background-color: #f0f0f0; padding: 12px; font-family: monospace; width: fit-content;">
let book4 = {<br>
&nbsp;&nbsp;title : "Javascript",<br>
&nbsp;&nbsp;pages : 500,<br>
&nbsp;&nbsp;author : "고경희",<br>
&nbsp;&nbsp;done : false,<br>
&nbsp;&nbsp;finish : function() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: red;">this.done</span> === false ? console.log("읽는 중") : console.log("완독");<br>
&nbsp;&nbsp;}<br>
}<br><br>
book4.finish() // "읽는 중"
</div>
<p>객체 복사하기</p>

<b>원시 유형 자료 복사</b><br>
<li>‘값’을 복사한다</li>
<li>복사한 자료의 값을 변경 → 원래 자료의 값은 그대로</li>
<br>
<img src="images/객체복사.png" alt="원시 유형 복사 설명"><br><br>

<b>객체 복사</b><br>
<li>‘주소’를 복사한다</li>
<li>복사한 자료의 값 변경 → 원래 자료의 값도 바뀐다</li>
<br>
<img src="images/객체복사2.png" alt="객체 주소 복사 설명">
<p>생성자 함수</p>

<li>객체마다 반복되는 프로퍼티와 메서드가 있다면 객체 틀을 미리 정의해 놓고 필요할 때마다 그 틀을 사용해서 객체를 만들 수 있다.</li>
<li>객체의 틀을 만들 때 사용하는 함수를 ‘생성자 함수’라고 한다.</li>
<li>생성자 함수를 사용해서 찍어 내는 객체를 ‘인스턴스’ 또는 ‘인스턴스 객체’라고 부른다.</li>

<br>
 <p>생성자 함수를 사용해 객체 정의하기</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>항목</th>
    <th>내용</th>
  </tr>
  <tr>
    <td>정의 방식</td>
    <td>생성자 함수는 일반적인 함수와 같은 형식</td>
  </tr>
  <tr>
    <td>이름 규칙</td>
    <td>함수 이름의 첫 글자는 <strong>대문자</strong>로 사용</td>
  </tr>
  <tr>
    <td>특징</td>
    <td><code>this</code>를 사용해 프로퍼티와 메서드를 정의</td>
  </tr>
  <tr>
    <td>기본 구조 1</td>
    <td>
      function 함수명(매개변수) {<br>
      &nbsp;&nbsp;this.키1 = 값1;<br>
      &nbsp;&nbsp;this.메서드1 = function() { ... };<br>
      }
    </td>
  </tr>
  <tr>
    <td>기본 구조 2</td>
    <td>
      const 함수명 = function(매개변수) {<br>
      &nbsp;&nbsp;// 내용<br>
      }
    </td>
  </tr>
</table>
<p>클래스를 사용해 객체 정의하기</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>항목</th>
    <th>내용</th>
  </tr>
  <tr>
    <td>클래스의 개념</td>
    <td>자바스크립트의 클래스는 생성자 함수를 쉽게 표현할 수 있도록 만든 <strong>신택틱 슈거(syntactic sugar)</strong></td>
  </tr>
  <tr>
    <td>기본 정의 방식</td>
    <td>
      class 클래스명 {<br>
      &nbsp;&nbsp;constructor() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 프로퍼티1, 프로퍼티2, ...<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;메서드1() { ... }<br>
      &nbsp;&nbsp;메서드2() { ... }<br>
      }
    </td>
  </tr>
  <tr>
    <td>또는</td>
    <td>
      const 클래스명 = class {<br>
      &nbsp;&nbsp;// 내용<br>
      }
    </td>
  </tr>
</table>
<p>for...in 사용하기</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>항목</th>
    <th>내용</th>
  </tr>
  <tr>
    <td>기본 문법</td>
    <td>
      <div style="background:#f4f4f4;padding:8px;">
        for (변수 in 객체) { ... }
      </div>
    </td>
  </tr>
  <tr>
    <td>특징</td>
    <td>객체의 **키(key)** 를 순회할 때 사용</td>
  </tr>
  <tr>
    <td>예시 객체</td>
    <td>
      <div style="background:#f4f4f4;padding:8px;">
        let bag = {<br>
        &nbsp;&nbsp;type: "backpack",<br>
        &nbsp;&nbsp;color: "blue",<br>
        &nbsp;&nbsp;size: 15<br>
        }
      </div>
    </td>
  </tr>
  <tr>
    <td>키만 출력</td>
    <td>
      <div style="background:#f4f4f4;padding:8px;">
        for (key in bag) {<br>
        &nbsp;&nbsp;console.log(`${key}`);<br>
        }<br>
        // 출력: type, color, size
      </div>
    </td>
  </tr>
  <tr>
    <td>키와 값 출력</td>
    <td>
      <div style="background:#f4f4f4;padding:8px;">
        for (key in bag) {<br>
        &nbsp;&nbsp;console.log(`${key} : ${bag[key]}`);<br>
        }<br>
        // 출력: type : backpack, color : blue, size : 15
      </div>
    </td>
  </tr>
</table>

<p>keys(), values(), entries() 메서드 사용하기</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>메서드</th>
    <th>설명</th>
  </tr>
  <tr>
    <td><code>Object.keys(객체명)</code></td>
    <td>객체의 키만 배열로 반환</td>
  </tr>
  <tr>
    <td><code>Object.values(객체명)</code></td>
    <td>객체의 값만 배열로 반환</td>
  </tr>
  <tr>
    <td><code>Object.entries(객체명)</code></td>
    <td>객체의 [키, 값] 쌍을 배열로 반환</td>
  </tr>
</table>

<br>

<p>(예) book1 객체의 키와 값 가져오기</p>
<div style="background:#f4f4f4;padding:8px;white-space:pre-line;font-family:monospace;">
let book1 = {
  title: "웹 표준의 정석",
  pages: 648,
  buy: function () {
    console.log("이 책을 구입했습니다.");
  }
}

let keys = Object.keys(book1);       // 키만 가져오기
console.log(keys);                   // ["title", "pages", "buy"]

let values = Object.values(book1);   // 값만 가져오기
console.log(values);

let entries = Object.entries(book1); // 키와 값 함께 가져오기
console.log(entries);
</div>
<p>프로토타입</p>

<ul>
  <li><code>prototype</code>은 객체 생성자 함수에 의해 생성되는 객체들이 공유하는 속성과 메서드를 저장하는 특수 객체</li>
  <li>프로토타입 객체는 객체 생성자 함수로 생성된 객체들이 <strong>공유하는 속성과 메서드</strong>를 저장하는 특별한 객체</li>
  <li>자바스크립트의 상속은 <strong>프로토타입</strong>을 통해 이루어짐</li>
</ul>

<br>

<ul>
  <li><code>[[Prototype]]</code> 속성: <code>arr</code> 객체가 어느 생성자 함수로부터 만들어졌는지 알려주는 속성</li>
  <li><code>arr</code> 배열의 프로토타입은 <code>Array</code> 객체이고, <code>arr</code> 배열은 <code>Array</code> 객체의 프로퍼티와 메서드를 상속받는다</li>
  <li>이때 <code>Array</code> 객체를 <code>arr</code> 배열의 <code>프로토타입(prototype)</code>이라고 한다</li>
</ul>
<p>생성자 함수와 프로토타입 객체</p>

<ul>
  <li>생성자 함수를 선언하는 순간 <strong>자동으로 프로토타입 객체</strong>가 만들어진다</li>
</ul>

<br>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>구문</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>
      <div style="background-color:#f4f4f4; padding:5px; font-family:monospace;">
        const Book = function(title, pages, done) { <br>
          ...<br>
        }<br><br>
        const book1 = new Book("웹 표준의 정석", 648, false);
      </div>
    </td>
    <td>
      생성자 함수 <code>Book</code>을 정의하고, <br>
      <code>new</code> 연산자를 통해 인스턴스 <code>book1</code> 생성
    </td>
  </tr>
  <tr>
    <td>
      <div style="background-color:#f4f4f4; padding:5px; font-family:monospace;">
        Book.prototype
      </div>
    </td>
    <td>
      생성자 함수 <code>Book</code>의 프로토타입 객체에 접근<br>
      이 객체는 모든 <code>Book</code> 인스턴스가 공유하는 속성과 메서드를 정의할 수 있음
    </td>
  </tr>
</table>

<br>

<ul>
  <li><strong>book1의 내부 [[Prototype]]은 Book.prototype을 참조</strong></li>
  <li><code>Book.prototype</code> 역시 <code>Object</code> 객체를 기반으로 함</li>
</ul>

<br>

<p>생성자 함수와 프로토타입 객체</p>

<ul>
  <li><strong>book1</strong>은 생성자 함수 <code>Book()</code>을 통해 생성된 객체</li>
  <li><strong>book1의 [[Prototype]]은 Book.prototype을 참조</strong></li>
  <li><strong>Book.prototype</strong>은 다시 <code>Object</code> 객체를 상속</li>
</ul>

<br>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>요소</th>
    <th>내용</th>
  </tr>
  <tr>
    <td><code>book1</code></td>
    <td>
      <ul>
        <li>title: "웹 표준의 정석"</li>
        <li>pages: 648</li>
        <li>done: false</li>
        <li>finish(): 메서드</li>
        <li><code>[[Prototype]] → Book.prototype</code></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><code>Book.prototype</code></td>
    <td>
      <ul>
        <li>constructor: Book(title, pages, done)</li>
        <li><code>[[Prototype]] → Object.prototype</code></li>
      </ul>
    </td>
  </tr>
</table>

<br>

<p><strong>book1은 Book.prototype의 속성과 메서드를 상속받음</strong></p>
<p>예: <code>book1.finish()</code> 호출 가능</p>

<br>
<p>__proto__ 와 prototype</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>구분</th>
    <th>__proto__ 프로퍼티</th>
    <th>prototype 프로퍼티</th>
  </tr>
  <tr>
    <td>정의</td>
    <td>모든 객체가 가지고 있는 프로퍼티<br>자신에게 연결된 프로토타입 객체를 참조</td>
    <td>모든 함수가 가지고 있는 프로퍼티<br>생성자 함수로부터 생성된 인스턴스들의 프로토타입 역할</td>
  </tr>
  <tr>
    <td>용도</td>
    <td>인스턴스 객체에서 연결된 프로토타입 객체 확인 시 사용</td>
    <td>해당 생성자 함수가 어떤 속성과 메서드를 제공하는지 확인 시 사용</td>
  </tr>
  <tr>
    <td>접근 예시</td>
    <td><code>book1.__proto__</code></td>
    <td><code>Book.prototype</code></td>
  </tr>
  <tr>
    <td>출력 결과 예시</td>
    <td>
      <ul>
        <li>constructor: Book()</li>
        <li>[[Prototype]]: Object</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>constructor: Book()</li>
        <li>메서드 목록 (toString, hasOwnProperty, 등)</li>
        <li>__proto__도 존재함</li>
      </ul>
    </td>
  </tr>
</table>

<br>

<p><strong>결론:</strong> <code>book1.__proto__ === Book.prototype</code> 은 <span style="color:red;">true</span></p>
<p>프로토타입 메서드</p>

<p>생성자 함수 밖에서 프로토타입을 사용해 새로운 메서드를 정의할 수 있다</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>구성 요소</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>생성자 함수 정의</td>
    <td>
      <pre>
function newBook(title, pages, done) {
  this.title = title;
  this.pages = pages;
  this.done = done;
}
      </pre>
    </td>
  </tr>
  <tr>
    <td>프로토타입 메서드 정의</td>
    <td>
      <pre>
newBook.prototype.finish = function() {
  let str = this.done === false ? "읽는 중" : "완독";
  return str;
};
      </pre>
    </td>
  </tr>
  <tr>
    <td>객체 생성</td>
    <td>
      <pre>
const nBook1 = new newBook("웹 표준의 정석", 648, false);
const nBook2 = new newBook("점프 투 파이썬", 360, true);
      </pre>
    </td>
  </tr>
  <tr>
    <td>프로토타입 체인</td>
    <td>
      <li>nBook1과 nBook2는 newBook 생성자 함수로부터 생성됨</li>
      <li>두 객체는 newBook.prototype을 자신의 프로토타입으로 가짐</li>
      <li>finish() 메서드는 각각의 객체에서 공유되어 사용됨</li>
    </td>
  </tr>
</table>
<p>프로토타입 상속</p>

<p>기존 생성자 함수의 속성과 메서드를 하위 생성자 함수에서 재사용할 수 있다.</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>구성 요소</th>
    <th>설명 및 코드</th>
  </tr>
  <tr>
    <td>상위 생성자 함수 정의</td>
    <td>
      <pre>
function Book(title, price) {
  this.title = title;
  this.price = price;
}
Book.prototype.buy = function() {
  console.log(`${this.title}을(를) ${this.price}원에 구매하였습니다.`);
};
      </pre>
    </td>
  </tr>
  <tr>
    <td>하위 생성자 함수 정의 및 상속</td>
    <td>
      <pre>
function Textbook(title, price, major) {
  Book.call(this, title, price); // 상위 생성자 재사용
  this.major = major;            // 하위 고유 속성
}
      </pre>
    </td>
  </tr>
  <tr>
    <td>하위 프로토타입 메서드 추가</td>
    <td>
      <pre>
Textbook.prototype.buyTextbook = function() {
  console.log(`${this.major} 전공 서적, ${this.title}을 구매했습니다.`);
};
      </pre>
    </td>
  </tr>
  <tr>
    <td>프로토타입 연결 (상속)</td>
    <td>
      <pre>
Object.setPrototypeOf(Textbook.prototype, Book.prototype);
      </pre>
      <li>Textbook 객체도 Book의 메서드 사용 가능</li>
    </td>
  </tr>
</table>
<p>클래스 상속</p>

<p>기존 클래스를 상속하여 새로운 클래스를 만들 수 있으며, <code>extends</code>와 <code>super()</code> 키워드를 사용한다.</p>

<table border="1" cellspacing="0" cellpadding="8">
  <tr>
    <th>구성 요소</th>
    <th>코드 및 설명</th>
  </tr>
  <tr>
    <td>상위 클래스 정의</td>
    <td>
      <pre>
class BookC {
  constructor(title, price) {
    this.title = title;
    this.price = price;
  }
  buy() {
    console.log(`${this.title}을(를) ${this.price}원에 구매하였습니다.`);
  }
}

const book1 = new BookC("자료 구조", 15000);
book1.buy();
      </pre>
    </td>
  </tr>
  <tr>
    <td>하위 클래스 정의 및 상속</td>
    <td>
      <pre>
class TextbookC extends BookC {
  constructor(title, price, major) {
    super(title, price);   // 상위 클래스 생성자 호출
    this.major = major;    // 하위 클래스 고유 속성
  }

  buyTextbook() {
    console.log(`${this.major} 전공 서적, ${this.title}을 구매했습니다.`);
  }
}
      </pre>
    </td>
  </tr>
</table>

